// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

buildscript {
  repositories {
    mavenCentral()
    jcenter()
  }
  dependencies {
    classpath "org.ajoberstar:grgit:1.9.3"
    classpath "com.github.siom79.japicmp:japicmp:0.13.0"
  }
}

import japicmp.cli.JApiCli
import org.ajoberstar.grgit.Grgit
import org.apache.tools.ant.DirectoryScanner

// Parameters
def baseBranch = project.hasProperty('baseBranch') ? project.baseBranch : "trunk"
def newBranch = project.hasProperty('newBranch') ? project.newBranch : "HEAD"
def onlyIncompatible = project.hasProperty('onlyIncompatible') ? project.onlyIncompatible : true
def failOnBinaryIncompatibility = project.hasProperty('failOnBinaryIncompatibility') ?
        project.failOnBinaryIncompatibility : false
def failOnSourceIncompatibility = project.hasProperty('failOnSourceIncompatibility') ?
        project.failOnSourceIncompatibility : false
def failOnModifications = project.hasProperty('failOnModifications') ?
        project.failOnModifications : false
def failOnSemanticIncompatibility = project.hasProperty('failOnSemanticIncompatibility') ?
        project.failOnSemanticIncompatibility : false

// Constants
def packageIncludes = [
  "org.apache.kafka.common.*",
  "org.apache.kafka.clients.*",
  "org.apache.kafka.connect.*",
]
def packageExcludes = [
  "org.apache.kafka.common.internals.*",
  "org.apache.kafka.clients.consumer.internals.*",
  "org.apache.kafka.clients.producer.internals.*",
  "org.apache.kafka.clients.common.internals.*",
]
def baseWorkspace = "$buildDir/tmp/compatibility/base"
def newWorkspace = "$buildDir/tmp/compatibility/new"
def reportDir = "$buildDir/reports/compatibility"
def reportFile = "$reportDir/compatibilityReport.html"
def rootRepo = Grgit.open(dir: rootProject.rootDir)

def repoExcludes = new ArrayList<String>(rootRepo.clean(ignore: false, directories: true, dryRun: true))

static def collectArtifactJars(String workspace) {
  String includesPattern = '**/build/libs/kafka-*.jar'
  String excludesPattern = '**/build/libs/*-javadoc.jar **/build/libs/*-sources.jar **/build/libs/*-test.jar'
  return new FileNameFinder().getFileNames(workspace, includesPattern, excludesPattern)
}

static def checkoutBranch(String workspace, String branch) {
  // Clean up and checkout the needed branch
  def repo = Grgit.open(dir: workspace)
  // Add and commit changes to support comparing un-committed work
  repo.add(patterns: ['*'], update: true)
  repo.commit(message: 'compatibility-check commit', all: true)
  // Switch to the correct ref and make sure the branch is clean
  repo.checkout(branch: 'compatibility-check', startPoint: branch, createBranch: true, orphan: true)
  repo.clean(ignore: false, directories: true)
}

task setNoDirectoryExclude {
  // Hack to remove Ant default excludes for copy. (Reset after)
  // See https://issues.gradle.org/browse/GRADLE-1883
  DirectoryScanner.defaultExcludes.each { DirectoryScanner.removeDefaultExclude it } // Reset at the bottom
  DirectoryScanner.addDefaultExclude 'something has to be in here or everything gets excluded'
}

task cleanWorkspaces {
  delete baseWorkspace
  delete newWorkspace
}

task checkoutCleanBaseBranch(dependsOn: [setNoDirectoryExclude, cleanWorkspaces]) {
  doLast {
    copy {
      from rootDir
      into baseWorkspace
      excludes = repoExcludes
    }
    checkoutBranch(baseWorkspace, baseBranch)
  }
}

task checkoutCleanNewBranch(dependsOn: [setNoDirectoryExclude, cleanWorkspaces]) {
  doLast {
    copy {
      from rootDir
      into newWorkspace
      excludes = repoExcludes
    }
    checkoutBranch(newWorkspace, newBranch)
  }
}

task buildBaseBranch(type: GradleBuild, dependsOn: checkoutCleanBaseBranch) {
  dir = baseWorkspace
  tasks = ['clean','jar']
}

task buildNewBranch(type: GradleBuild, dependsOn: checkoutCleanNewBranch) {
  dir = newWorkspace
  tasks = ['clean','jar']
}

task apiCompatibilityReport(dependsOn: [buildBaseBranch, buildNewBranch]) {
  group 'API Compatibility Report'
  description 'Generates an API compatibility report with the japicmp library. ' +
          'It checks both binary and source compatibility.'
  doLast {
    // See Hack comment above
    DirectoryScanner.resetDefaultExcludes()
    // Setup the report file
    new File(reportDir).mkdirs()
    new File(reportFile).createNewFile()

    // Artifacts and Classpaths
    def baseArtifacts = collectArtifactJars(baseWorkspace)
    def newArtifacts = collectArtifactJars(newWorkspace)

    // Build check tool arguments
    String[] args = [
            "--ignore-missing-classes",
            "--old", baseArtifacts.join(";"),
            "--new", newArtifacts.join(";"),
            "--include", packageIncludes.join(";"),
            "--exclude", packageExcludes.join(";"),
            "--only-modified",
            "-a", "protected",
            "--html-file", reportFile
    ]

    if(onlyIncompatible) {
      args = args + ["--only-incompatible"]
    }
    if (failOnBinaryIncompatibility) {
      args = args + ["--error-on-binary-incompatibility"]
    }
    if (failOnSourceIncompatibility) {
      args = args + ["--error-on-source-incompatibility"]
    }
    if (failOnModifications) {
      args = args + ["--error-on-modifications"]
    }
    if (failOnSemanticIncompatibility) {
      args = args + ["--error-on-semantic-incompatibility"]
    }


    // Run the check tool
    JApiCli cli = new JApiCli()
    cli.run(args)

    println("API Compatibility report available in ${new File(reportFile).toURI()}")
  }
}

